/* Generated By:JavaCC: Do not edit this line. FilterParser.java */
package com.alibaba.napoli.metamorphosis.filter;

import java.io.StringReader;

import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * A JavaCC 2.0 grammar for HornetQ filters
 *
 * @author Scott.Stark@jboss.org
 * @author adrian@jboss.org
 * @version $Revision: 179889 $
 */
public class FilterParser implements FilterParserConstants {private static final String LOFFER_L = "l";
private static final String UPPER_L = "L";
private static final String OX = "0X";
private static final String Ox = "0x";
private static final String ZERRO = "0";

private Map identifierMap;

public FilterParser()
{
   // keep the parser from freaking out, init using one of
   // the JavaCC generated constructor
   this(new StringReader(""));
}

public Object parse(SimpleString selector, Map identifierMap)
   throws ParseException
{
   return parse(selector, identifierMap, false);
}

public Object parse(SimpleString selector, Map identifierMap, boolean trace)
   throws ParseException
{
   SimpleStringReader sr = new SimpleStringReader(selector);
   ReInit(sr);

   // This will have no effect unless the debugging options are true      
   if (trace)
   {
      this.enable_tracing();
   }
   else
   {
      this.disable_tracing();
   }

   this.identifierMap = identifierMap;
   return this.expression();
}

/**
 * Strip off the leading and trailing (quote) chars from the given string
 * and return it. 
 */
private SimpleString stripQuotes(String image)
{
   StringBuffer result = new StringBuffer(image.length()-2);
   int i = 1;
   boolean escaped = false;
   while (i < image.length() - 1)
   {
      if (escaped)
      {
         if (image.charAt(i) == '\'')
            result.append('\'');
         else
            throw new RuntimeException("Invalid uses of quotes: " + image);
         escaped = false;
      }
      else if (image.charAt(i) == '\'')
         escaped = true;
      else
         result.append(image.charAt(i));
      ++i;
   }
   return new SimpleString(result.toString());
}

public static Object doParse(SimpleString selector, Map identifierMap)
   throws ParseException
{
   return doParse(selector, identifierMap, false);
}

public static Object doParse(SimpleString selector, Map identifierMap, boolean trace)
   throws ParseException
{
   FilterParser parser = new FilterParser();
   return parser.parse(selector, identifierMap, trace);
}

/** Start of the grammar */
final public Object expression() throws ParseException {
Object exp1 = null;
 exp1 = selectorExpression();
 jj_consume_token(0);
   {if (true) return exp1;}
 throw new Error("Missing return statement in function");
}

final public Object selectorExpression() throws ParseException {
Object exp1 = null;
Object exp2 = null;
 exp1 = selectorTerm();
 label_1:
 while (true) {
   switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
   case OR:
     ;
     break;
   default:
     jj_la1[0] = jj_gen;
     break label_1;
   }
   jj_consume_token(OR);
   exp2 = selectorTerm();
       exp1 = new Operator(Operator.OR, exp1, exp2);
 }
   {if (true) return exp1;}
 throw new Error("Missing return statement in function");
}

final public Object selectorTerm() throws ParseException {
Object exp1 = null;
Object exp2 = null;
 exp1 = selectorFactor();
 label_2:
 while (true) {
   switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
   case AND:
     ;
     break;
   default:
     jj_la1[1] = jj_gen;
     break label_2;
   }
   jj_consume_token(AND);
   exp2 = selectorFactor();
       exp1 = new Operator(Operator.AND, exp1, exp2);
 }
   {if (true) return exp1;}
 throw new Error("Missing return statement in function");
}

final public Object selectorFactor() throws ParseException {
Object exp1 = null;
 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
 case TRUE:
 case FALSE:
 case LPAREN:
 case MINUS:
 case PLUS:
 case INTEGER_LITERAL:
 case FLOATING_POINT_LITERAL:
 case SIMPLE_STRING:
 case IDENTIFIER:
   exp1 = conditionalExpression();
   {if (true) return exp1;}
   break;
 case NOT:
   jj_consume_token(NOT);
   exp1 = conditionalExpression();
   exp1 = new Operator(Operator.NOT, exp1);
   {if (true) return exp1;}
   break;
 default:
   jj_la1[2] = jj_gen;
   jj_consume_token(-1);
   throw new ParseException();
 }
 throw new Error("Missing return statement in function");
}

final public Object conditionalExpression() throws ParseException {
Object exp1 = null;
 if (jj_2_1(3)) {
   jj_consume_token(LPAREN);
   exp1 = selectorExpression();
   jj_consume_token(RPAREN);
   {if (true) return exp1;}
 } else {
   switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
   case TRUE:
   case FALSE:
   case LPAREN:
   case MINUS:
   case PLUS:
   case INTEGER_LITERAL:
   case FLOATING_POINT_LITERAL:
   case SIMPLE_STRING:
   case IDENTIFIER:
     exp1 = comparisonExpression();
   {if (true) return exp1;}
     break;
   default:
     jj_la1[3] = jj_gen;
     jj_consume_token(-1);
     throw new ParseException();
   }
 }
 throw new Error("Missing return statement in function");
}

final public Object comparisonExpression() throws ParseException {
int op = -1;
Set set = null;
Object exp1 = null;
Object exp2 = null;
Object exp3 = null;
Object id = null;
Token not = null;
 if (jj_2_2(2147483647)) {
   exp1 = identifier();
   jj_consume_token(IS);
   switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
   case NOT:
     not = jj_consume_token(NOT);
     break;
   default:
     jj_la1[4] = jj_gen;
     ;
   }
   jj_consume_token(NULL);
   int opCode = not == null ? Operator.IS_NULL : Operator.IS_NOT_NULL;
   {if (true) return new Operator(opCode, exp1);}
 } else if (jj_2_3(2147483647)) {
   id = identifier();
   switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
   case NOT:
     not = jj_consume_token(NOT);
     break;
   default:
     jj_la1[5] = jj_gen;
     ;
   }
   jj_consume_token(IN);
   jj_consume_token(LPAREN);
                                              set = new HashSet();
   stringList(set);
   jj_consume_token(RPAREN);
   if (not == null)
      {if (true) return new Operator(Operator.IN, id, set);}
   else
      {if (true) return new Operator(Operator.NOT_IN, id, set);}
   {if (true) return exp1;}
 } else if (jj_2_4(2147483647)) {
   id = identifier();
   switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
   case NOT:
     not = jj_consume_token(NOT);
     break;
   default:
     jj_la1[6] = jj_gen;
     ;
   }
   jj_consume_token(LIKE);
   exp1 = patternExpression(id);
   if (not != null)
      exp1 = new Operator(Operator.NOT, exp1);
   {if (true) return exp1;}
 } else if (jj_2_5(2147483647)) {
   exp1 = stringExpression();
   switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
   case EQ:
     jj_consume_token(EQ);
         op = Operator.EQUAL;
     break;
   case NE:
     jj_consume_token(NE);
         op = Operator.DIFFERENT;
     break;
   default:
     jj_la1[7] = jj_gen;
     jj_consume_token(-1);
     throw new ParseException();
   }
   exp2 = stringExpression();
   {if (true) return new Operator(op, exp1, exp2);}
 } else if (jj_2_6(2147483647)) {
   exp1 = booleanExpression();
   switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
   case EQ:
     jj_consume_token(EQ);
         op = Operator.EQUAL;
     break;
   case NE:
     jj_consume_token(NE);
         op = Operator.DIFFERENT;
     break;
   default:
     jj_la1[8] = jj_gen;
     jj_consume_token(-1);
     throw new ParseException();
   }
   exp2 = booleanExpression();
   {if (true) return new Operator(op, exp1, exp2);}
 } else if (jj_2_7(2147483647)) {
   exp1 = arithExpression();
   switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
   case EQ:
     jj_consume_token(EQ);
         op = Operator.EQUAL;
     break;
   case NE:
     jj_consume_token(NE);
         op = Operator.DIFFERENT;
     break;
   case GT:
     jj_consume_token(GT);
         op = Operator.GT;
     break;
   case GE:
     jj_consume_token(GE);
         op = Operator.GE;
     break;
   case LT:
     jj_consume_token(LT);
         op = Operator.LT;
     break;
   case LE:
     jj_consume_token(LE);
         op = Operator.LE;
     break;
   default:
     jj_la1[9] = jj_gen;
     jj_consume_token(-1);
     throw new ParseException();
   }
   exp2 = arithExpression();
   {if (true) return new Operator(op, exp1, exp2);}
 } else if (jj_2_8(2147483647)) {
   exp1 = arithExpression();
   switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
   case NOT:
     not = jj_consume_token(NOT);
     break;
   default:
     jj_la1[10] = jj_gen;
     ;
   }
   jj_consume_token(BETWEEN);
   exp2 = arithExpression();
   jj_consume_token(AND);
   exp3 = arithExpression();
   exp1 = new Operator(Operator.BETWEEN, exp1, exp2, exp3);
   if (not != null)
      exp1 = new Operator(Operator.NOT, exp1);
   {if (true) return exp1;}
 } else {
   switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
   case TRUE:
   case FALSE:
   case IDENTIFIER:
     exp1 = booleanExpression();
   {if (true) return exp1;}
     break;
   default:
     jj_la1[11] = jj_gen;
     jj_consume_token(-1);
     throw new ParseException();
   }
 }
 throw new Error("Missing return statement in function");
}

final public void stringList(Set set) throws ParseException {
 stringToken(set);
 label_3:
 while (true) {
   switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
   case COMMA:
     ;
     break;
   default:
     jj_la1[12] = jj_gen;
     break label_3;
   }
   jj_consume_token(COMMA);
   stringToken(set);
 }
}

final public void stringToken(Set set) throws ParseException {
Token t = null;
 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
 case SIMPLE_STRING:
   t = jj_consume_token(SIMPLE_STRING);
   break;
 default:
   jj_la1[13] = jj_gen;
   ;
 }
   if (t != null)
     set.add(stripQuotes(t.image));
}

final public Object patternExpression(Object exp1) throws ParseException {
Object exp2 = null;
Token esc = null;
Object escChar = null;
 exp2 = stringLiteral();
 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
 case ESCAPE:
   esc = jj_consume_token(ESCAPE);
   escChar = stringLiteral();
   break;
 default:
   jj_la1[14] = jj_gen;
   ;
 }
   Operator op = null;
   if (esc == null)
      op = new Operator(Operator.LIKE, exp1, exp2);
   else
      op = new Operator(Operator.LIKE_ESCAPE, exp1, exp2, escChar);
   {if (true) return op;}
 throw new Error("Missing return statement in function");
}

final public Object arithExpression() throws ParseException {
Object exp1 = null;
Object exp2 = null;
 exp1 = arithTerm();
 label_4:
 while (true) {
   switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
   case MINUS:
   case PLUS:
     ;
     break;
   default:
     jj_la1[15] = jj_gen;
     break label_4;
   }
   switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
   case PLUS:
     jj_consume_token(PLUS);
     exp2 = arithTerm();
       exp1 = new Operator(Operator.ADD, exp1, exp2);
     break;
   case MINUS:
     jj_consume_token(MINUS);
     exp2 = arithTerm();
       exp1 = new Operator(Operator.SUB, exp1, exp2);
     break;
   default:
     jj_la1[16] = jj_gen;
     jj_consume_token(-1);
     throw new ParseException();
   }
 }
   {if (true) return exp1;}
 throw new Error("Missing return statement in function");
}

final public Object arithTerm() throws ParseException {
Object exp1 = null;
Object exp2 = null;
 exp1 = arithFactor();
 label_5:
 while (true) {
   switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
   case MULT:
   case DIV:
     ;
     break;
   default:
     jj_la1[17] = jj_gen;
     break label_5;
   }
   switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
   case MULT:
     jj_consume_token(MULT);
     exp2 = arithFactor();
       exp1 = new Operator(Operator.MUL, exp1, exp2);
     break;
   case DIV:
     jj_consume_token(DIV);
     exp2 = arithFactor();
       exp1 = new Operator(Operator.DIV, exp1, exp2);
     break;
   default:
     jj_la1[18] = jj_gen;
     jj_consume_token(-1);
     throw new ParseException();
   }
 }
   {if (true) return exp1;}
 throw new Error("Missing return statement in function");
}

final public Object arithFactor() throws ParseException {
Object exp1 = null;
boolean negate = false;
 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
 case MINUS:
 case PLUS:
   switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
   case PLUS:
     jj_consume_token(PLUS);
     break;
   case MINUS:
     jj_consume_token(MINUS);
                 negate = true;
     break;
   default:
     jj_la1[19] = jj_gen;
     jj_consume_token(-1);
     throw new ParseException();
   }
   break;
 default:
   jj_la1[20] = jj_gen;
   ;
 }
 exp1 = numericExpression();
   if (negate)
      exp1 = new Operator(Operator.NEG, exp1);
   {if (true) return exp1;}
 throw new Error("Missing return statement in function");
}

final public Object booleanExpression() throws ParseException {
Object exp1 = null;
 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
 case IDENTIFIER:
   exp1 = identifier();
   break;
 case TRUE:
 case FALSE:
   exp1 = booleanLiteral();
   break;
 default:
   jj_la1[21] = jj_gen;
   jj_consume_token(-1);
   throw new ParseException();
 }
   {if (true) return exp1;}
 throw new Error("Missing return statement in function");
}

final public Object booleanLiteral() throws ParseException {
boolean isTrue = true;
 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
 case TRUE:
   jj_consume_token(TRUE);
   break;
 case FALSE:
   jj_consume_token(FALSE);
                 isTrue = false;
   break;
 default:
   jj_la1[22] = jj_gen;
   jj_consume_token(-1);
   throw new ParseException();
 }
   if (isTrue)
      {if (true) return Boolean.TRUE;}
   else
      {if (true) return Boolean.FALSE;}
 throw new Error("Missing return statement in function");
}

final public Object stringExpression() throws ParseException {
Object exp1 = null;
 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
 case IDENTIFIER:
   exp1 = identifier();
   break;
 case SIMPLE_STRING:
   exp1 = stringLiteral();
   break;
 default:
   jj_la1[23] = jj_gen;
   jj_consume_token(-1);
   throw new ParseException();
 }
   {if (true) return exp1;}
 throw new Error("Missing return statement in function");
}

final public Object stringLiteral() throws ParseException {
Token string = null;
 string = jj_consume_token(SIMPLE_STRING);
   {if (true) return stripQuotes(string.image);}
 throw new Error("Missing return statement in function");
}

final public Object numericExpression() throws ParseException {
Object exp1 = null;
 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
 case INTEGER_LITERAL:
 case FLOATING_POINT_LITERAL:
   exp1 = numericLiteral();
   break;
 case LPAREN:
   jj_consume_token(LPAREN);
   exp1 = arithExpression();
   jj_consume_token(RPAREN);
   break;
 case IDENTIFIER:
   exp1 = identifier();
   break;
 default:
   jj_la1[24] = jj_gen;
   jj_consume_token(-1);
   throw new ParseException();
 }
   {if (true) return exp1;}
 throw new Error("Missing return statement in function");
}

final public Object numericLiteral() throws ParseException {
Token literal = null;
 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
 case FLOATING_POINT_LITERAL:
   literal = jj_consume_token(FLOATING_POINT_LITERAL);
   {if (true) return new Double(literal.image);}
   break;
 case INTEGER_LITERAL:
   literal = jj_consume_token(INTEGER_LITERAL);
   String number = literal.image;

   // long suffix
   if (number.endsWith(LOFFER_L) || number.endsWith(UPPER_L))
   {
      // chop off the suffix
      {if (true) return new Long(number.substring(0, number.length() - 1));}
   }

   // hex
   if (number.startsWith(OX) || number.startsWith(Ox))
   {
      // handle literals from 0x8000000000000000L to 0xffffffffffffffffL:
      // remove sign bit, parse as positive, then calculate the negative
      // value with the sign bit
      if(number.length() == 18)
      {
         byte first = Byte.decode(number.substring(0, 3)).byteValue();
         if (first >= 8)
         {
            number = Ox + (first - 8) + number.substring(3);
            {if (true) return new Long(Long.decode(number).longValue() - Long.MAX_VALUE - 1);}
         }
      }
   }
   else if (number.startsWith(ZERRO))
   {
      // octal
      // handle literals
      // from 01000000000000000000000L to 01777777777777777777777L
      // remove sign bit, parse as positive, then calculate the
      // negative value with the sign bit
      if (number.length() == 23)
      {
         if (number.charAt(1) == '1')
         {
            number = ZERRO + number.substring(2);
            {if (true) return new Long(Long.decode(number).longValue() - Long.MAX_VALUE - 1);}
         }
      }
   }
   {if (true) return Long.decode(number);}
   break;
 default:
   jj_la1[25] = jj_gen;
   jj_consume_token(-1);
   throw new ParseException();
 }
 throw new Error("Missing return statement in function");
}

final public Object identifier() throws ParseException {
Token id = null;
 id = jj_consume_token(IDENTIFIER);
   SimpleString simage = new SimpleString(id.image);
   Identifier identifier = (Identifier) identifierMap.get(simage);
   if (identifier == null)
   {
      identifier = new Identifier(simage);
      identifierMap.put(simage, identifier);
        }
   {if (true) return identifier;}
 throw new Error("Missing return statement in function");
}

final private boolean jj_2_1(int xla) {
 jj_la = xla; jj_lastpos = jj_scanpos = token;
 try { return !jj_3_1(); }
 catch(LookaheadSuccess ls) { return true; }
 finally { jj_save(0, xla); }
}

final private boolean jj_2_2(int xla) {
 jj_la = xla; jj_lastpos = jj_scanpos = token;
 try { return !jj_3_2(); }
 catch(LookaheadSuccess ls) { return true; }
 finally { jj_save(1, xla); }
}

final private boolean jj_2_3(int xla) {
 jj_la = xla; jj_lastpos = jj_scanpos = token;
 try { return !jj_3_3(); }
 catch(LookaheadSuccess ls) { return true; }
 finally { jj_save(2, xla); }
}

final private boolean jj_2_4(int xla) {
 jj_la = xla; jj_lastpos = jj_scanpos = token;
 try { return !jj_3_4(); }
 catch(LookaheadSuccess ls) { return true; }
 finally { jj_save(3, xla); }
}

final private boolean jj_2_5(int xla) {
 jj_la = xla; jj_lastpos = jj_scanpos = token;
 try { return !jj_3_5(); }
 catch(LookaheadSuccess ls) { return true; }
 finally { jj_save(4, xla); }
}

final private boolean jj_2_6(int xla) {
 jj_la = xla; jj_lastpos = jj_scanpos = token;
 try { return !jj_3_6(); }
 catch(LookaheadSuccess ls) { return true; }
 finally { jj_save(5, xla); }
}

final private boolean jj_2_7(int xla) {
 jj_la = xla; jj_lastpos = jj_scanpos = token;
 try { return !jj_3_7(); }
 catch(LookaheadSuccess ls) { return true; }
 finally { jj_save(6, xla); }
}

final private boolean jj_2_8(int xla) {
 jj_la = xla; jj_lastpos = jj_scanpos = token;
 try { return !jj_3_8(); }
 catch(LookaheadSuccess ls) { return true; }
 finally { jj_save(7, xla); }
}

final private boolean jj_3R_23() {
 if (jj_3R_35()) return true;
 Token xsp;
 while (true) {
   xsp = jj_scanpos;
   if (jj_3R_36()) { jj_scanpos = xsp; break; }
 }
 return false;
}

final private boolean jj_3R_46() {
 Token xsp;
 xsp = jj_scanpos;
 if (jj_3R_51()) {
 jj_scanpos = xsp;
 if (jj_3R_52()) {
 jj_scanpos = xsp;
 if (jj_3R_53()) return true;
 }
 }
 return false;
}

final private boolean jj_3_6() {
 if (jj_3R_13()) return true;
 Token xsp;
 xsp = jj_scanpos;
 if (jj_3R_14()) {
 jj_scanpos = xsp;
 if (jj_3R_15()) return true;
 }
 if (jj_3R_13()) return true;
 return false;
}

final private boolean jj_3R_12() {
 if (jj_scan_token(NE)) return true;
 return false;
}

final private boolean jj_3R_41() {
 if (jj_scan_token(MINUS)) return true;
 if (jj_3R_33()) return true;
 return false;
}

final private boolean jj_3R_11() {
 if (jj_scan_token(EQ)) return true;
 return false;
}

final private boolean jj_3R_40() {
 if (jj_scan_token(PLUS)) return true;
 if (jj_3R_33()) return true;
 return false;
}

final private boolean jj_3R_34() {
 Token xsp;
 xsp = jj_scanpos;
 if (jj_3R_40()) {
 jj_scanpos = xsp;
 if (jj_3R_41()) return true;
 }
 return false;
}

final private boolean jj_3R_28() {
 if (jj_scan_token(ESCAPE)) return true;
 if (jj_3R_27()) return true;
 return false;
}

final private boolean jj_3R_24() {
 if (jj_scan_token(OR)) return true;
 return false;
}

final private boolean jj_3_5() {
 if (jj_3R_10()) return true;
 Token xsp;
 xsp = jj_scanpos;
 if (jj_3R_11()) {
 jj_scanpos = xsp;
 if (jj_3R_12()) return true;
 }
 if (jj_3R_10()) return true;
 return false;
}

final private boolean jj_3R_27() {
 if (jj_scan_token(SIMPLE_STRING)) return true;
 return false;
}

final private boolean jj_3R_16() {
 if (jj_3R_33()) return true;
 Token xsp;
 while (true) {
   xsp = jj_scanpos;
   if (jj_3R_34()) { jj_scanpos = xsp; break; }
 }
 return false;
}

final private boolean jj_3R_6() {
 if (jj_3R_23()) return true;
 Token xsp;
 while (true) {
   xsp = jj_scanpos;
   if (jj_3R_24()) { jj_scanpos = xsp; break; }
 }
 return false;
}

final private boolean jj_3_4() {
 if (jj_3R_7()) return true;
 Token xsp;
 xsp = jj_scanpos;
 if (jj_scan_token(10)) jj_scanpos = xsp;
 if (jj_scan_token(LIKE)) return true;
 if (jj_3R_9()) return true;
 return false;
}

final private boolean jj_3R_30() {
 if (jj_3R_27()) return true;
 return false;
}

final private boolean jj_3R_29() {
 if (jj_3R_7()) return true;
 return false;
}

final private boolean jj_3R_7() {
 if (jj_scan_token(IDENTIFIER)) return true;
 return false;
}

final private boolean jj_3R_10() {
 Token xsp;
 xsp = jj_scanpos;
 if (jj_3R_29()) {
 jj_scanpos = xsp;
 if (jj_3R_30()) return true;
 }
 return false;
}

final private boolean jj_3_3() {
 if (jj_3R_7()) return true;
 Token xsp;
 xsp = jj_scanpos;
 if (jj_scan_token(10)) jj_scanpos = xsp;
 if (jj_scan_token(IN)) return true;
 if (jj_scan_token(LPAREN)) return true;
 if (jj_3R_8()) return true;
 if (jj_scan_token(RPAREN)) return true;
 return false;
}

final private boolean jj_3R_44() {
 if (jj_scan_token(FALSE)) return true;
 return false;
}

final private boolean jj_3R_9() {
 if (jj_3R_27()) return true;
 Token xsp;
 xsp = jj_scanpos;
 if (jj_3R_28()) jj_scanpos = xsp;
 return false;
}

final private boolean jj_3R_26() {
 if (jj_scan_token(COMMA)) return true;
 if (jj_3R_25()) return true;
 return false;
}

final private boolean jj_3R_56() {
 Token xsp;
 xsp = jj_scanpos;
 if (jj_3_2()) {
 jj_scanpos = xsp;
 if (jj_3_3()) {
 jj_scanpos = xsp;
 if (jj_3_4()) {
 jj_scanpos = xsp;
 if (jj_3_5()) {
 jj_scanpos = xsp;
 if (jj_3_6()) {
 jj_scanpos = xsp;
 if (jj_3_7()) {
 jj_scanpos = xsp;
 if (jj_3_8()) {
 jj_scanpos = xsp;
 if (jj_3R_59()) return true;
 }
 }
 }
 }
 }
 }
 }
 return false;
}

final private boolean jj_3_2() {
 if (jj_3R_7()) return true;
 if (jj_scan_token(IS)) return true;
 Token xsp;
 xsp = jj_scanpos;
 if (jj_scan_token(10)) jj_scanpos = xsp;
 if (jj_scan_token(NULL)) return true;
 return false;
}

final private boolean jj_3R_37() {
 Token xsp;
 xsp = jj_scanpos;
 if (jj_scan_token(6)) {
 jj_scanpos = xsp;
 if (jj_3R_44()) return true;
 }
 return false;
}

final private boolean jj_3R_25() {
 Token xsp;
 xsp = jj_scanpos;
 if (jj_scan_token(37)) jj_scanpos = xsp;
 return false;
}

final private boolean jj_3R_32() {
 if (jj_3R_37()) return true;
 return false;
}

final private boolean jj_3R_31() {
 if (jj_3R_7()) return true;
 return false;
}

final private boolean jj_3R_54() {
 if (jj_3R_56()) return true;
 return false;
}

final private boolean jj_3R_13() {
 Token xsp;
 xsp = jj_scanpos;
 if (jj_3R_31()) {
 jj_scanpos = xsp;
 if (jj_3R_32()) return true;
 }
 return false;
}

final private boolean jj_3R_8() {
 if (jj_3R_25()) return true;
 Token xsp;
 while (true) {
   xsp = jj_scanpos;
   if (jj_3R_26()) { jj_scanpos = xsp; break; }
 }
 return false;
}

final private boolean jj_3R_50() {
 if (jj_scan_token(MINUS)) return true;
 return false;
}

final private boolean jj_3R_49() {
 Token xsp;
 xsp = jj_scanpos;
 if (jj_3_1()) {
 jj_scanpos = xsp;
 if (jj_3R_54()) return true;
 }
 return false;
}

final private boolean jj_3_1() {
 if (jj_scan_token(LPAREN)) return true;
 if (jj_3R_6()) return true;
 if (jj_scan_token(RPAREN)) return true;
 return false;
}

final private boolean jj_3R_59() {
 if (jj_3R_13()) return true;
 return false;
}

final private boolean jj_3R_45() {
 Token xsp;
 xsp = jj_scanpos;
 if (jj_scan_token(24)) {
 jj_scanpos = xsp;
 if (jj_3R_50()) return true;
 }
 return false;
}

final private boolean jj_3R_38() {
 Token xsp;
 xsp = jj_scanpos;
 if (jj_3R_45()) jj_scanpos = xsp;
 if (jj_3R_46()) return true;
 return false;
}

final private boolean jj_3_8() {
 if (jj_3R_16()) return true;
 Token xsp;
 xsp = jj_scanpos;
 if (jj_scan_token(10)) jj_scanpos = xsp;
 if (jj_scan_token(BETWEEN)) return true;
 if (jj_3R_16()) return true;
 if (jj_scan_token(AND)) return true;
 if (jj_3R_16()) return true;
 return false;
}

final private boolean jj_3R_43() {
 if (jj_scan_token(NOT)) return true;
 if (jj_3R_49()) return true;
 return false;
}

final private boolean jj_3R_22() {
 if (jj_scan_token(LE)) return true;
 return false;
}

final private boolean jj_3R_58() {
 if (jj_scan_token(INTEGER_LITERAL)) return true;
 return false;
}

final private boolean jj_3R_21() {
 if (jj_scan_token(LT)) return true;
 return false;
}

final private boolean jj_3R_42() {
 if (jj_3R_49()) return true;
 return false;
}

final private boolean jj_3R_35() {
 Token xsp;
 xsp = jj_scanpos;
 if (jj_3R_42()) {
 jj_scanpos = xsp;
 if (jj_3R_43()) return true;
 }
 return false;
}

final private boolean jj_3R_20() {
 if (jj_scan_token(GE)) return true;
 return false;
}

final private boolean jj_3R_48() {
 if (jj_scan_token(DIV)) return true;
 if (jj_3R_38()) return true;
 return false;
}

final private boolean jj_3R_19() {
 if (jj_scan_token(GT)) return true;
 return false;
}

final private boolean jj_3R_18() {
 if (jj_scan_token(NE)) return true;
 return false;
}

final private boolean jj_3R_17() {
 if (jj_scan_token(EQ)) return true;
 return false;
}

final private boolean jj_3R_57() {
 if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
 return false;
}

final private boolean jj_3R_55() {
 Token xsp;
 xsp = jj_scanpos;
 if (jj_3R_57()) {
 jj_scanpos = xsp;
 if (jj_3R_58()) return true;
 }
 return false;
}

final private boolean jj_3R_47() {
 if (jj_scan_token(MULT)) return true;
 if (jj_3R_38()) return true;
 return false;
}

final private boolean jj_3R_39() {
 Token xsp;
 xsp = jj_scanpos;
 if (jj_3R_47()) {
 jj_scanpos = xsp;
 if (jj_3R_48()) return true;
 }
 return false;
}

final private boolean jj_3_7() {
 if (jj_3R_16()) return true;
 Token xsp;
 xsp = jj_scanpos;
 if (jj_3R_17()) {
 jj_scanpos = xsp;
 if (jj_3R_18()) {
 jj_scanpos = xsp;
 if (jj_3R_19()) {
 jj_scanpos = xsp;
 if (jj_3R_20()) {
 jj_scanpos = xsp;
 if (jj_3R_21()) {
 jj_scanpos = xsp;
 if (jj_3R_22()) return true;
 }
 }
 }
 }
 }
 if (jj_3R_16()) return true;
 return false;
}

final private boolean jj_3R_36() {
 if (jj_scan_token(AND)) return true;
 return false;
}

final private boolean jj_3R_33() {
 if (jj_3R_38()) return true;
 Token xsp;
 while (true) {
   xsp = jj_scanpos;
   if (jj_3R_39()) { jj_scanpos = xsp; break; }
 }
 return false;
}

final private boolean jj_3R_53() {
 if (jj_3R_7()) return true;
 return false;
}

final private boolean jj_3R_15() {
 if (jj_scan_token(NE)) return true;
 return false;
}

final private boolean jj_3R_52() {
 if (jj_scan_token(LPAREN)) return true;
 if (jj_3R_16()) return true;
 if (jj_scan_token(RPAREN)) return true;
 return false;
}

final private boolean jj_3R_14() {
 if (jj_scan_token(EQ)) return true;
 return false;
}

final private boolean jj_3R_51() {
 if (jj_3R_55()) return true;
 return false;
}

public FilterParserTokenManager token_source;
SimpleCharStream jj_input_stream;
public Token token, jj_nt;
private int jj_ntk;
private Token jj_scanpos, jj_lastpos;
private int jj_la;
public boolean lookingAhead = false;
private boolean jj_semLA;
private int jj_gen;
final private int[] jj_la1 = new int[26];
static private int[] jj_la1_0;
static private int[] jj_la1_1;
static {
   jj_la1_0();
   jj_la1_1();
}
private static void jj_la1_0() {
   jj_la1_0 = new int[] {0x800,0x200,0x818204c0,0x818200c0,0x400,0x400,0x400,0x60000000,0x60000000,0x7e000000,0x400,0xc0,0x100000,0x0,0x10000,0x1800000,0x1800000,0x600000,0x600000,0x1800000,0x1800000,0xc0,0xc0,0x0,0x80020000,0x80000000,};
}
private static void jj_la1_1() {
   jj_la1_1 = new int[] {0x0,0x0,0x68,0x68,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x60,0x48,0x8,};
}
final private JJCalls[] jj_2_rtns = new JJCalls[8];
private boolean jj_rescan = false;
private int jj_gc = 0;

public FilterParser(java.io.InputStream stream) {
  this(stream, null);
}
public FilterParser(java.io.InputStream stream, String encoding) {
 try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
 token_source = new FilterParserTokenManager(jj_input_stream);
 token = new Token();
 jj_ntk = -1;
 jj_gen = 0;
 for (int i = 0; i < 26; i++) jj_la1[i] = -1;
 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
}

public void ReInit(java.io.InputStream stream) {
  ReInit(stream, null);
}
public void ReInit(java.io.InputStream stream, String encoding) {
 try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
 token_source.ReInit(jj_input_stream);
 token = new Token();
 jj_ntk = -1;
 jj_gen = 0;
 for (int i = 0; i < 26; i++) jj_la1[i] = -1;
 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
}

public FilterParser(java.io.Reader stream) {
 jj_input_stream = new SimpleCharStream(stream, 1, 1);
 token_source = new FilterParserTokenManager(jj_input_stream);
 token = new Token();
 jj_ntk = -1;
 jj_gen = 0;
 for (int i = 0; i < 26; i++) jj_la1[i] = -1;
 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
}

public void ReInit(java.io.Reader stream) {
 jj_input_stream.ReInit(stream, 1, 1);
 token_source.ReInit(jj_input_stream);
 token = new Token();
 jj_ntk = -1;
 jj_gen = 0;
 for (int i = 0; i < 26; i++) jj_la1[i] = -1;
 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
}

public FilterParser(FilterParserTokenManager tm) {
 token_source = tm;
 token = new Token();
 jj_ntk = -1;
 jj_gen = 0;
 for (int i = 0; i < 26; i++) jj_la1[i] = -1;
 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
}

public void ReInit(FilterParserTokenManager tm) {
 token_source = tm;
 token = new Token();
 jj_ntk = -1;
 jj_gen = 0;
 for (int i = 0; i < 26; i++) jj_la1[i] = -1;
 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
}

final private Token jj_consume_token(int kind) throws ParseException {
 Token oldToken;
 if ((oldToken = token).next != null) token = token.next;
 else token = token.next = token_source.getNextToken();
 jj_ntk = -1;
 if (token.kind == kind) {
   jj_gen++;
   if (++jj_gc > 100) {
     jj_gc = 0;
     for (int i = 0; i < jj_2_rtns.length; i++) {
       JJCalls c = jj_2_rtns[i];
       while (c != null) {
         if (c.gen < jj_gen) c.first = null;
         c = c.next;
       }
     }
   }
   return token;
 }
 token = oldToken;
 jj_kind = kind;
 throw generateParseException();
}

static private final class LookaheadSuccess extends java.lang.Error { }
final private LookaheadSuccess jj_ls = new LookaheadSuccess();
final private boolean jj_scan_token(int kind) {
 if (jj_scanpos == jj_lastpos) {
   jj_la--;
   if (jj_scanpos.next == null) {
     jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
   } else {
     jj_lastpos = jj_scanpos = jj_scanpos.next;
   }
 } else {
   jj_scanpos = jj_scanpos.next;
 }
 if (jj_rescan) {
   int i = 0; Token tok = token;
   while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
   if (tok != null) jj_add_error_token(kind, i);
 }
 if (jj_scanpos.kind != kind) return true;
 if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
 return false;
}

final public Token getNextToken() {
 if (token.next != null) token = token.next;
 else token = token.next = token_source.getNextToken();
 jj_ntk = -1;
 jj_gen++;
 return token;
}

final public Token getToken(int index) {
 Token t = lookingAhead ? jj_scanpos : token;
 for (int i = 0; i < index; i++) {
   if (t.next != null) t = t.next;
   else t = t.next = token_source.getNextToken();
 }
 return t;
}

final private int jj_ntk() {
 if ((jj_nt=token.next) == null)
   return (jj_ntk = (token.next=token_source.getNextToken()).kind);
 else
   return (jj_ntk = jj_nt.kind);
}

private java.util.Vector jj_expentries = new java.util.Vector();
private int[] jj_expentry;
private int jj_kind = -1;
private int[] jj_lasttokens = new int[100];
private int jj_endpos;

private void jj_add_error_token(int kind, int pos) {
 if (pos >= 100) return;
 if (pos == jj_endpos + 1) {
   jj_lasttokens[jj_endpos++] = kind;
 } else if (jj_endpos != 0) {
   jj_expentry = new int[jj_endpos];
   for (int i = 0; i < jj_endpos; i++) {
     jj_expentry[i] = jj_lasttokens[i];
   }
   boolean exists = false;
   for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
     int[] oldentry = (int[])(e.nextElement());
     if (oldentry.length == jj_expentry.length) {
       exists = true;
       for (int i = 0; i < jj_expentry.length; i++) {
         if (oldentry[i] != jj_expentry[i]) {
           exists = false;
           break;
         }
       }
       if (exists) break;
     }
   }
   if (!exists) jj_expentries.addElement(jj_expentry);
   if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
 }
}

public ParseException generateParseException() {
 jj_expentries.removeAllElements();
 boolean[] la1tokens = new boolean[41];
 for (int i = 0; i < 41; i++) {
   la1tokens[i] = false;
 }
 if (jj_kind >= 0) {
   la1tokens[jj_kind] = true;
   jj_kind = -1;
 }
 for (int i = 0; i < 26; i++) {
   if (jj_la1[i] == jj_gen) {
     for (int j = 0; j < 32; j++) {
       if ((jj_la1_0[i] & (1<<j)) != 0) {
         la1tokens[j] = true;
       }
       if ((jj_la1_1[i] & (1<<j)) != 0) {
         la1tokens[32+j] = true;
       }
     }
   }
 }
 for (int i = 0; i < 41; i++) {
   if (la1tokens[i]) {
     jj_expentry = new int[1];
     jj_expentry[0] = i;
     jj_expentries.addElement(jj_expentry);
   }
 }
 jj_endpos = 0;
 jj_rescan_token();
 jj_add_error_token(0, 0);
 int[][] exptokseq = new int[jj_expentries.size()][];
 for (int i = 0; i < jj_expentries.size(); i++) {
   exptokseq[i] = (int[])jj_expentries.elementAt(i);
 }
 return new ParseException(token, exptokseq, tokenImage);
}

final public void enable_tracing() {
}

final public void disable_tracing() {
}

final private void jj_rescan_token() {
 jj_rescan = true;
 for (int i = 0; i < 8; i++) {
 try {
   JJCalls p = jj_2_rtns[i];
   do {
     if (p.gen > jj_gen) {
       jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
       switch (i) {
         case 0: jj_3_1(); break;
         case 1: jj_3_2(); break;
         case 2: jj_3_3(); break;
         case 3: jj_3_4(); break;
         case 4: jj_3_5(); break;
         case 5: jj_3_6(); break;
         case 6: jj_3_7(); break;
         case 7: jj_3_8(); break;
       }
     }
     p = p.next;
   } while (p != null);
   } catch(LookaheadSuccess ls) { }
 }
 jj_rescan = false;
}

final private void jj_save(int index, int xla) {
 JJCalls p = jj_2_rtns[index];
 while (p.gen > jj_gen) {
   if (p.next == null) { p = p.next = new JJCalls(); break; }
   p = p.next;
 }
 p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
}

static final class JJCalls {
 int gen;
 Token first;
 int arg;
 JJCalls next;
}}
